Common Intermediate Language (CIL)

How and when it's compiled into binary code by the JIT compiler.

Compiler turns .cs files into binary code, but there's more, two compilers.

When we build, the compiler (Named Roslyn), starts working, taking the .cs files and compiling them into CIL code which has a similar structure to java's bytecode. It's human readable, but not as much.

After we start it, the JIT compiler compiles the CIL into binary code and we can actually run that. It allows cross-platform compatibility so long as you have the .NET framework (which isn't C#, it's more akin to a framework, C# just so happens to be what we run on it most of the time.)

Not all files are compiled when we run as well since it's a JIT compiler.


Common Language Runtime (CLR)

It's a runtime environment that manages the execution of .NET apps.
Does the work we'd need to do on a lower level language like C, or ASM, like managing memory allocation.

The CLR manages all programs under .NET, so your F# or Iron Python apps as well.

A few of its responsibilities:

JIT Compilation;
Memory management (includes garbage collection);
Error handling;
Thread management.

Step by step, it goes like:

Step 1. We write code;
Step 2. Compiler compiles code into CIL;
Step 3. CLR kicks in, starts the program;
Step 4. CLR JIT compiles the CIL to binary;
Step 5. CLR manages the resources available to it & low level responsibilities.


MEMORY. Stack and heap.

We allocate memory no matter what we're doing, specifically, RAM.

Memory addresses, which are used on lower level languages by way of pointers... When we manipulate a variable in code, we're technically using the pointer, but in a different manner. In C, we can send an entire pointer as the parameter of a function, which in turn would allow us to make a function which technically returns no value but does manipulate the input which we sent to it, so much so that we could reset the address altogether and that memory address would forever become unavailable until we reset the machine.

Stack:

One per thread
Stacks are small, 1-4MB
No gaps between data
Automatical removal
Faster

Heap:

One per app
Heaps are larger
Can have chunks of empty data, defragmented
Cleaned up by the garbage collector
Slower

Example of value semantics & reference semantics in code on a project called "ReferenceVsValue"

TLDR of it, though:

Value is the value being held by it
Reference would be more akin to the place it is stored

While we can do
int num1 = 5;
int num2 = num1;
num2++;
And num2's value and hashcode will be different because they're different variables, if we make a custom object like
Person person1 = new Person();
Person person2 = person1;
If we run a person1.Equals(person2), the result will be true, and if we modify a variable in person2, or person1, they will both be modified. This is because we didn't create a new object for person2, we merely "told" it that it now holds the location of person1.



Value types:
Value semantics;
Derived from System.ValueType;
Simple build-in types, (int, decimal, DateTime, bool, etc.)
These are all structs.

Reference types:
Reference semantics;
Derived from System.Object;
Build-in classes and our classes are them.
List<T>, object, array.
All classes.

The real difference is that
var listA = new List<T>;
listA holds a reference to the location of it in memory, so much so that we can lose the values entirely if we do...

var listA = new List<T>;
var listB = new List<T>;
listA = listB;

The code above would make it impossible to ever get the values out of the list it used to refer to.

int a = 5; in the meantime, 'a' stores the value.

We make copies of values, like jotting down information on different pieces of paper. What we write on paper1 won't change paper2's values.

We don't make copies of references, we merely point towards them. Like asking where the paper in the previous example is located at.


As for what goes on in memory;

Value types are sent to the stack due to their simplicity.
Reference types on the other hand, the value of the reference is sent to the stack while the actual data is sent to the heap.
(The above explanation is simplified, aka, abstracted.)



Boxed types.
Universal types, boxed.

Value types are stored in the stack...
The references of a custom class, however, are on the stack. (the pointer)
The actual values, the object, are in the heap.

'object' types, though,
int number = 5;
Person person = new Person(value, value);
object boxedNumber = number;
boxedNumber is a 'reference' type variable, while its value is a 'value' type

The stack vs heap for that is
Stack
number (5), reference to person, reference to boxedNumber

Heap
Values of person (the object itself), object wrapping the number (object(5))

Boxing happens implicitly each time we assign a value type to an instance of reference type. (Most typically, System.Object.)

Interface types are also reference types, so
IComparable<int> intAsComparable = number;
Is a reference type wrapping a value type.

Boxing appears to be wrapping a value type in a reference type.
Unboxing is converting the boxed value back to the value type.
Unboxing must be done explicitly,
int unboxedNumber = (int)boxedNumber;

Boxing can be done implicitly because it'll always work, because everything can be assigned to a system.object type, but unboxing would fail if the value stored inside an object doesn't match the given type, so it must be done explicitly.

An error would be thrown if we did
short unboxedNumber = (short)boxedNumber;
instead of the example above, the error?
InvalidCastException.

Boxing: Wrapping a value type into an instance of System.Object, which is  areference type.
It's necessary to use all types in C# in a uniform way as objects.
Unboxing is the opposite, returning the boxed value to its original value type.
It does come with a performance penalty.

PERFORMANCE OF BOXING.

int a = 5; -> size of int: 4 bytes
object b = 5; -> size of int: 4 bytes, size of reference 4/8 bytes, total size? 8/12 bytes.
Create new object -> Allocate memory -> Cast on unboxing